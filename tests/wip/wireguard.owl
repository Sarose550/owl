set_option ":rlimit" "2000000"
/*

type := 0x1 (1 byte) 
reserved := 0^3 (3 bytes)
sender := I_i (4 bytes)
ephemeral (32 bytes)
static (32 bytes)
timestamp (12 bytes)
mac1 (16 bytes) 
mac2 (16 bytes)

CONSTANTS:
construction -> 0x636f6e737472756374696f6e
identifier -> 0x6964656e746966696572
mac1--- -> 0x6d6163312d2d2d

*/

func construction() = 0x636f6e737472756374696f6e
func identifier() = 0x6964656e746966696572 
func mac1() = 0x6d6163312d2d2d


locality Initiator
locality Responder

// Ephemeral Diffie-Hellman keys
name E_init : DH @ Initiator
name E_resp : DH @ Responder

// Static Diffie-Hellman keys (public keys should be preshared)
name S_init : DH @ Initiator
name S_resp : DH @ Responder

func msg1_C2_aad() = 
    crh(crh(crh(crh(construction()) ++ identifier()) ++ dhpk(get(S_resp))) ++ dhpk(get(E_init)))

func msg1_C3_aad(c) = 
    crh(msg1_C2_aad() ++ c)
    

// TODO: problematic for disjointness
name msg1_C1 : RO strict crh(construction()) ++ dhpk(get(E_init)) -> nonce
name msg1_C1_resp_corr : RO[x] strict crh(construction()) ++ x -> nonce
    requires is_group_elem(x)
    requires x != dhpk(get(E_init))
    uniqueness_by ()

counter aead_counter_msg1_C2 @ Initiator
name msg1_C2 : RO strict{0} get(msg1_C1) ++ dh_combine(dhpk(get(S_resp)), get(E_init)) -> nonce || 
    st_aead dhpk(S_init)
            aad x. x == msg1_C2_aad()
            nonce aead_counter_msg1_C2
            nonce_pattern *
            uniqueness_by {
                is_constant_lemma(crh(construction()))
            }

type Empty = (x:Data<adv>{false})

name msg1_C2_resp_corr : RO[x] strict{0} get(msg1_C1_resp_corr[x;0]) ++ dh_combine(x, get(S_resp)) -> nonce || enckey Empty
    requires is_group_elem(x)
    requires x != dhpk(get(E_init))
    uniqueness_by {
                is_constant_lemma(crh(construction()))
    }

corr[x] adv ==> [msg1_C2_resp_corr[x;1]]

counter aead_counter_msg1_C3 @ Initiator
name msg1_C3 : RO strict{0} get(msg1_C2[;0]) ++ dh_combine(dhpk(get(S_resp)), get(S_init)) -> nonce || 
    st_aead (Data<adv> |12|)
            aad x. (exists c:bv. x == msg1_C3_aad(c))
            nonce aead_counter_msg1_C3
            nonce_pattern *
    uniqueness_by {    is_constant_lemma(crh(construction())) }

name msg1_C3_resp_corr : RO[x] strict{0}  get(msg1_C2_resp_corr[x;0]) ++ dh_combine(dhpk(get(S_resp)), get(S_init)) 
    -> nonce || enckey Empty
    requires is_group_elem(x)
    requires x != dhpk(get(E_init))
    uniqueness_by {    is_constant_lemma(crh(construction())) }

corr [x] adv ==> [msg1_C3_resp_corr[x;1]]

// needs to use the crh hash function, rather than kdf
// TODO: problematic for RO disjointness
name msg1_mac1_key : RO strict{0} mac1() ++ dhpk(get(S_resp)) -> mackey Data<adv> 
    uniqueness_by { assume (mac1() != crh(construction())); 
                    is_constant_lemma(crh(construction())) }

    
name msg2_C4 : RO strict{0} get(msg1_C3[;0]) ++ dhpk(get(E_resp)) -> nonce
    uniqueness_by { is_constant_lemma(crh(construction())) }

name msg2_C4_resp_corr : RO[x] strict{0} get(msg1_C3_resp_corr[x;0]) ++ dhpk(get(E_resp)) -> nonce
    requires is_group_elem(x)
    requires x != dhpk(get(E_init))
    uniqueness_by { is_constant_lemma(crh(construction())) }



name msg2_C4_init_corr : RO[y] strict{0} get(msg1_C3[;0]) ++ y -> nonce
    requires is_group_elem(y)
    requires y != dhpk(get(E_resp))
    uniqueness_by { is_constant_lemma(crh(construction())) }
    
corr[y] adv ==> [msg2_C4_init_corr[y;0]]


name msg2_C5 : RO strict{0} get(msg2_C4[;0]) ++ dh_combine(dhpk(get(E_init)), get(E_resp)) -> nonce
    uniqueness_by { is_constant_lemma(crh(construction())) }

name msg2_C5_resp_corr : RO[x] strict{0} get(msg2_C4_resp_corr[x;0]) ++ dh_combine(x, get(E_resp)) -> nonce
    requires is_group_elem(x)
    requires x != dhpk(get(E_init))
    uniqueness_by { is_constant_lemma(crh(construction())) }

name msg2_C5_init_corr : RO[x] strict{0} get(msg2_C4_init_corr[x;0]) ++ dh_combine(x, get(E_init)) -> nonce
    requires is_group_elem(x)
    requires x != dhpk(get(E_resp))
    uniqueness_by { is_constant_lemma(crh(construction())) }


name msg2_C6 : RO strict{0} get(msg2_C5[;0]) ++ dh_combine(dhpk(get(S_init)), get(E_resp)) -> nonce
    uniqueness_by { disjoint_not_eq_lemma(get(msg2_C5[;0]), crh(construction())); () }

name msg2_C6_resp_corr : RO[x] strict{0} get(msg2_C5_resp_corr[x;0]) ++ dh_combine(dhpk(get(S_init)), get(E_resp)) -> nonce
    requires is_group_elem(x)
    requires x != dhpk(get(E_init))
    uniqueness_by { is_constant_lemma(crh(construction())) }

name msg2_C6_init_corr : RO[x] strict{0} get(msg2_C5_init_corr[x;0]) ++ dh_combine(x, get(S_init)) -> nonce
    requires is_group_elem(x)
    requires x != dhpk(get(E_resp))
    uniqueness_by { is_constant_lemma(crh(construction())) }

counter aead_counter_msg2_C7 @ Responder

func msg2_C7_aad(c, ts, tau) = 
    crh(crh(crh(msg1_C3_aad(c) ++ ts) ++ dhpk(get(E_init))) ++ tau)
    

        

name msg2_C7 : RO strict{0} get(msg2_C6[;0]) ++ (0x00000000) -> nonce || nonce || 
    st_aead (Data<adv> |0|)
            aad x. true
            //aad x.  exists c:bv, ts:bv, tau:bv. x == msg2_C7_aad(c, ts, tau)
            nonce aead_counter_msg2_C7
            nonce_pattern *
    uniqueness_by { is_constant_lemma(crh(construction()));
        disjoint_not_eq_lemma(get(msg2_C6[;0]) ++ (0x00000000), preimage(msg1_mac1_key));
        assume (forall x:bv. is_group_elem(x) ==> 
            length (get(msg2_C6[;0]) ++ (0x00000000)) != length(preimage(msg1_C1_resp_corr[x])))
    }

corr adv ==> [msg2_C7[;1]]

name msg2_C7_resp_corr : RO[x] strict{0} get(msg2_C6_resp_corr[x;0]) ++ (0x00000000) -> nonce || nonce || enckey Empty
    requires is_group_elem(x)
    requires x != dhpk(get(E_init))
    uniqueness_by { 
        disjoint_not_eq_lemma(get(msg2_C6_resp_corr[x;0]) ++ (0x00000000), preimage(msg1_mac1_key));
        assume (forall x:bv. is_group_elem(x) ==> 
            length (get(msg2_C6_resp_corr[x;0]) ++ (0x00000000)) != length(preimage(msg1_C1_resp_corr[x])))
    }
        

corr[x] adv ==> [msg2_C7_resp_corr[x;1]]
corr[x] adv ==> [msg2_C7_resp_corr[x;2]]


name msg2_C7_init_corr : RO[x] strict{0} get(msg2_C6_init_corr[x;0]) ++ (0x00000000) -> nonce || nonce || 
    (st_aead Empty
            aad x. true
            // aad x.  exists c:bv, ts:bv, tau:bv. x == msg2_C7_aad(c, ts, tau)
            nonce aead_counter_msg2_C7
            nonce_pattern *)
    requires is_group_elem(x)
    requires x != dhpk(get(E_resp))
    uniqueness_by { 
        disjoint_not_eq_lemma(get(msg2_C6_init_corr[x;0]) ++ (0x00000000), preimage(msg1_mac1_key));
        assume (forall x:bv. is_group_elem(x) ==> 
            length (get(msg2_C6_init_corr[x;0]) ++ (0x00000000)) != length(preimage(msg1_C1_resp_corr[x])))
    }

corr[x] adv ==> [msg2_C7_init_corr[x;1]]



// needs to use the crh hash function, rather than kdf
name msg2_mac1_key : RO mac1() ++ dhpk(get(S_init)) -> mackey Data<adv>
    uniqueness_by { 
        is_constant_lemma(crh(construction()));
        assume (forall x:bv. is_group_elem(x) ==> 
         mac1() ++ dhpk(get(S_init)) !=
         preimage(msg2_C7_init_corr[x]));
        assume (forall x:bv. is_group_elem(x) ==> 
         mac1() ++ dhpk(get(S_init)) !=
         preimage(msg2_C7_resp_corr[x]));
        disjoint_not_eq_lemma(mac1() ++ dhpk(get(S_init)),
        preimage(msg2_C7));
        assume (forall x:bv. is_group_elem(x) ==> 
         mac1() ++ dhpk(get(S_init)) !=
         preimage(msg1_C1_resp_corr[x]))
    }

locality dummy // TODO just for now

name channel_secret : nonce @ dummy
corr [S_init] ==> [channel_secret]
corr [S_resp] ==> [channel_secret]

type payload_i2r = Data<adv /\ [channel_secret], |adv|>
type payload_r2i = Data<adv /\ [channel_secret], |adv|>

counter N_init_send @ Initiator
counter N_init_recv @ Initiator
counter N_resp_send @ Responder
counter N_resp_recv @ Responder

// T_init_send = T_resp_recv || T_resp_send = T_init_recv
name transp_T : RO get(msg2_C7[;0]) ++ 0x -> 
    st_aead payload_i2r
        aad x. true
        nonce N_init_send
        nonce_pattern * ||
    st_aead payload_r2i
        aad x. true
        nonce N_resp_send
        nonce_pattern *
    uniqueness_by { 
        is_constant_lemma(crh(construction()));
        disjoint_not_eq_lemma(get(msg2_C7[;0]) ++ 0x, preimage(msg2_mac1_key));
        disjoint_not_eq_lemma(get(msg2_C7[;0]) ++ 0x, preimage(msg1_mac1_key));
        assume (forall x:bv.
            is_group_elem(x) ==> 
            length(get(msg2_C7[;0]) ++ 0x) != length(preimage(msg1_C1_resp_corr[x])))
        }

name transp_T_resp_corr : RO[x] strict get(msg2_C7_resp_corr[x;0]) ++ 0x -> 
    st_aead payload_i2r
        aad x. true
        nonce N_init_send
        nonce_pattern * ||
    st_aead payload_r2i
        aad x. true
        nonce N_resp_send
        nonce_pattern *
    requires is_group_elem(x)
    uniqueness_by { 
        assume (length(get(msg2_C7_resp_corr[x;0]) ++ 0x) != length(preimage(msg2_mac1_key)));
        assume (forall y:bv. 
            is_group_elem(y) ==>
                length(get(msg2_C7_resp_corr[x;0]) ++ 0x) !=
                length(preimage(msg1_C1_resp_corr[y])));
        is_constant_lemma(crh(construction())) }

name transp_T_init_corr : RO[x] strict get(msg2_C7_init_corr[x;0]) ++ 0x -> 
    st_aead payload_i2r
        aad x. true
        nonce N_init_send
        nonce_pattern * ||
    st_aead payload_r2i
        aad x. true
        nonce N_resp_send
        nonce_pattern *
    requires is_group_elem(x)
    uniqueness_by { 
        assume (length(get(msg2_C7_init_corr[x;0]) ++ 0x) != length(preimage(msg2_mac1_key)));
        assume (forall y:bv. 
            is_group_elem(y) ==>
                length(get(msg2_C7_init_corr[x;0]) ++ 0x) !=
                length(preimage(msg1_C1_resp_corr[y])));
        is_constant_lemma(crh(construction())) }
    

////////////////////////////
// Message formats

struct msg1_payload {
      _msg1_reserved : Data<adv> |3|
    , _msg1_sender : Data<adv> |4| // bytes??
    , _msg1_ephemeral : dhpk(E_init)
    , _msg1_static : Data<adv> | cipherlen(length(dhpk(get(S_init)))) |
    , _msg1_timestamp: Data<adv> | cipherlen(12) |
    // TODO cookie mechanism
    , _msg1_mac1: Data<adv> | |maclen| |
    // , _msg1_mac2: Data<adv> | |maclen| |
}

struct msg2_payload {
      _msg2_reserved : Data<adv> |3|
    , _msg2_sender: Data<adv> |4|
    , _msg2_receiver: Data<adv> |4|
    , _msg2_ephemeral: dhpk(E_resp)
    , _msg2_empty: Data<adv> | cipherlen(0) |
    // TODO cookie mechanism
    , _msg2_mac1: Data<adv> | |maclen| |
    // , _msg2_mac2: Data<adv> | |maclen| |
}

struct transp_payload {
      _transp_reserved : Data<adv> |3|
    , _transp_receiver : Data<adv> |4|
    , _transp_counter  : Data<adv> | 8 | // TODO need Data<adv> | |counter| |
    , _transp_packet   : Data<adv> 
}

enum msg {
    | msg1 msg1_payload     // 0x1
    | msg2 msg2_payload     // 0x2
    | unused_tag_filler     // 0x3 (tag not used in wireguard)
    | transp transp_payload // 0x4
}

////////////////////////////
// Primitives

def get_padding_i () @ Initiator : Data<adv> |3| // TODO primitive for zero bytes?
def get_sender_i  () @ Initiator : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_i   () @ Initiator : Data<adv> |12|
def get_empty_i   () @ Initiator : Data<adv> |0|

def get_padding_r () @ Responder : Data<adv> |3| // TODO primitive for zero bytes?
def get_sender_r  () @ Responder : Data<adv> |4| // TODO can we model this as a nonce?
def timestamp_r   () @ Responder : Data<adv> |12|
def get_empty_r   () @ Responder : Data<adv> |0|

////////////////////////////
// Return data

struct initiator_msg1_val {
      _initiator_msg1_C3 : Name(msg1_C3[;0])
    , _initiator_msg1_H4 : Data<adv> // todo
}

struct responder_msg1_val {
      _responder_msg1_C3 : Data<top> | |nonce| | 
    , _responder_msg1_H4 : Data<adv> // todo
    , _responder_msg1_ephemeral : Data<adv>
    , _responder_msg1_sender : Data<adv> |4|
}

predicate valid_responder_msg1_val (s) = 
    let eph = _responder_msg1_ephemeral(s) in 
    is_group_elem(eph) /\ 
    ((eph == dhpk(get(E_init))) ==> (
        _responder_msg1_C3(s) == get(msg1_C3[;0])
    )) 
    /\ ((eph != dhpk(get(E_init))) ==> 
        _responder_msg1_C3(s) == get(msg1_C3_resp_corr[eph;0]) /\
        (corr(msg1_C3_resp_corr[eph;0]) ==> corr(S_init) \/ corr(S_resp)))

type responder_msg1_val_t = s:responder_msg1_val {valid_responder_msg1_val[s]}

struct transp_keys {
      _transp_keys_initiator : Data<adv> |4|  // value of get_sender_i
    , _transp_keys_responder : Data<adv> |4|  // value of get_sender_r
    , _transp_keys_init_ephemeral : Data<adv> // TODO should be ghost
    , _transp_keys_resp_ephemeral : Data<adv> // TODO should be ghost
    , _transp_keys_T_init_send : Data<top> | |enckey| |
    , _transp_keys_T_resp_send : Data<top> | |enckey| |
}

predicate valid_transp_keys_init(s) = 
    let dh_other = _transp_keys_resp_ephemeral(s) in 
    (_transp_keys_init_ephemeral(s) == dhpk(get(E_init)))
    /\
    is_group_elem(dh_other)
    /\
    (dh_other == dhpk(get(E_resp)) ==>
        _transp_keys_T_init_send(s) == get(transp_T[;0]) /\
        _transp_keys_T_resp_send(s) == get(transp_T[;1]))
    /\
    (dh_other != dhpk(get(E_resp)) ==>
        _transp_keys_T_init_send(s) == get(transp_T_init_corr[dh_other;0]) /\
        _transp_keys_T_resp_send(s) == get(transp_T_init_corr[dh_other;1]) /\
        (corr(transp_T_init_corr[dh_other;0]) ==>
            (corr(S_init) \/ corr(S_resp)))
    )
        
    
type transp_keys_init_t = s:transp_keys {valid_transp_keys_init[s]}

predicate valid_transp_keys_resp(s) = 
    let dh_other = _transp_keys_init_ephemeral(s) in 
    (_transp_keys_resp_ephemeral(s) == dhpk(get(E_resp)))
    /\
    is_group_elem(dh_other)
    /\
    (dh_other == dhpk(get(E_init)) ==>
        _transp_keys_T_init_send(s) == get(transp_T[;0]) /\
        _transp_keys_T_resp_send(s) == get(transp_T[;1]))
    /\
    (dh_other != dhpk(get(E_init)) ==>
        _transp_keys_T_init_send(s) == get(transp_T_resp_corr[dh_other;0]) /\
        _transp_keys_T_resp_send(s) == get(transp_T_resp_corr[dh_other;1]) /\
        (corr(transp_T_resp_corr[dh_other;0]) ==>
            (corr(S_init) \/ corr(S_resp)))
    ) 
    
type transp_keys_resp_t = s:transp_keys {valid_transp_keys_resp[s]}
        
        
def off_chain_resp(er : 
    (x:Data<top>{is_group_elem(x) /\ x != dhpk(get(E_init))}), dhpk_S_init : dhpk(S_init)) @ Responder : Unit = 
    let c1 = hash<msg1_C1_resp_corr[er]>(crh(construction()), er) in
    let c2 = hash<msg1_C2_resp_corr[er]>(c1, dh_combine(er, get(S_resp))) in
    let c3 = hash<msg1_C3_resp_corr[er]>(c2, dh_combine(dhpk_S_init, get(S_resp))) in 
    let c4 = hash<msg2_C4_resp_corr[er]>(c3, dhpk(get(E_resp))) in 
    let c5 = hash<msg2_C5_resp_corr[er]>(c4, dh_combine(er, get(E_resp))) in
    let c6 = hash<msg2_C6_resp_corr[er]>(c5, dh_combine(dhpk_S_init, get(E_resp))) in
    let c7 = hash<msg2_C7_resp_corr[er]>(c6, 0x00000000) in
    let tsend = hash<transp_T_resp_corr[er]>(c7, 0x) in 
    assert (corr(msg2_C7_resp_corr[er;0]) ==>
                (corr(S_init) \/ corr(E_resp))
                /\
                (corr(S_init) \/ corr(S_resp))
    )

def off_chain_init(er : (x:Data<top>{is_group_elem(x) /\ x != dhpk(get(E_resp))}), dhpk_S_resp : dhpk(S_resp)) @ Initiator : Unit = 
    let c1 = hash<msg1_C1>(crh(construction()), dhpk(get(E_init))) in
    let c2 = hash<msg1_C2>(c1, dh_combine(dhpk_S_resp, get(E_init))) in
    let c3 = hash<msg1_C3>(c2, dh_combine(dhpk_S_resp, get(S_init))) in 
    let c4 = hash<msg2_C4_init_corr[er]>(c3, er) in 
    let c5 = hash<msg2_C5_init_corr[er]>(c4, dh_combine(er, get(E_init))) in
    let c6 = hash<msg2_C6_init_corr[er]>(c5, dh_combine(er, get(S_init))) in
    let c7 = hash<msg2_C7_init_corr[er]>(c6, 0x00000000) in
    let tsend = hash<transp_T_init_corr[er]>(c7, 0x) in 
    assert (corr(msg2_C7_init_corr[er;0]) ==>
              (corr(S_resp) \/ corr(S_init))
              \/
              (corr(S_resp) \/ corr(E_init))
    )




def generate_msg1 (dhpk_S_resp : dhpk(S_resp)) @ Initiator : initiator_msg1_val =
    let C0 = crh(construction()) in
    let H0 = crh(C0 ++ identifier()) in 
    let H1 = crh(H0 ++ dhpk_S_resp) in
    let C1 = hash<msg1_C1>(C0, dhpk(get(E_init))) in 
    let msg1_ephemeral = dhpk(get(E_init)) in
    let H2 = crh(H1 ++ msg1_ephemeral) in
    let C2 = hash<msg1_C2;0>(C1, dh_combine(dhpk_S_resp, get(E_init))) in
    let k0 = hash<msg1_C2;1>(C1, dh_combine(dhpk_S_resp, get(E_init))) in
    let msg1_static : Data<adv> |cipherlen(length(dhpk(get(S_init))))| 
        = st_aead_enc<aead_counter_msg1_C2>(k0, dhpk(get(S_init)), H2) in 
    let H3 = crh(H2 ++ msg1_static) in
    let C3 = hash<msg1_C3;0>(C2, dh_combine(dhpk_S_resp, get(S_init))) in
    let k1 = hash<msg1_C3;1>(C2, dh_combine(dhpk_S_resp, get(S_init))) in
    let timestamp = call timestamp_i() in
    let msg1_timestamp : Data<adv> |cipherlen(12)| =
    st_aead_enc<aead_counter_msg1_C3>(k1, timestamp, H3) in 
    let H4 = crh(H3 ++ timestamp) in

    let msg1_sender : Data<adv> |4| = call get_sender_i() in
    let msg1_reserved : Data<adv> |3| = call get_padding_i() in

    let msg1_mac1_k = hash<msg1_mac1_key>(mac1(), dhpk_S_resp) in 
    // TODO this needs to incorporate the tag byte 
    let msg1_mac1 : Data<adv> | |maclen| | = mac(msg1_mac1_k, 
        msg1_reserved ++ msg1_sender ++ msg1_ephemeral ++ msg1_static ++ msg1_timestamp) in
    let msg1_payload_value = msg1_payload(msg1_reserved, msg1_sender,
    msg1_ephemeral, msg1_static, msg1_timestamp, msg1_mac1) in
    let msg1_output = msg1(msg1_payload_value) in
    let _ = output msg1_output in 
    
    let retval = initiator_msg1_val(C3, H4) in
    retval


def receive_msg1 (dhpk_S_init : dhpk(S_init)) @ Responder 
     : Option (responder_msg1_val_t) 
     =
     set_option ":rlimit" "2000000" in 
     input inp in
     let msg1_reserved = _msg1_reserved(inp) in
     let msg1_sender = _msg1_sender(inp) in 
     let msg1_ephemeral = _msg1_ephemeral(inp) in
     let msg1_static = _msg1_static(inp) in
     let msg1_timestamp = _msg1_timestamp(inp) in
     let msg1_mac1 = _msg1_mac1(inp) in
     guard eq(length(msg1_sender), 4) in 
     guard is_group_elem(msg1_ephemeral) in 
     let C0 = crh(construction()) in
     let H0 = crh(C0 ++ identifier()) in 
     let H1 = crh(H0 ++ dhpk(get(S_resp))) in
     pcase (msg1_ephemeral != dhpk(get(E_init))) in
     let C1 = hash<msg1_C1, msg1_C1_resp_corr[msg1_ephemeral]>(C0, msg1_ephemeral) in 
     let H2 = crh(H1 ++ msg1_ephemeral) in

     let C2 = hash<msg1_C2, msg1_C2_resp_corr[msg1_ephemeral];0>(C1, dh_combine(msg1_ephemeral, get(S_resp))) in
     let k0 = hash<msg1_C2, msg1_C2_resp_corr[msg1_ephemeral];1>(C1, dh_combine(msg1_ephemeral, get(S_resp))) in

     corr_case msg1_C2[;1] when (msg1_ephemeral == dhpk(get(E_init))) in
     corr_case msg1_C2_resp_corr[msg1_ephemeral;1] when (msg1_ephemeral != dhpk(get(E_init))) in
     case st_aead_dec(k0, msg1_static, 0x, H2) {
         | None => None<ty:responder_msg1_val_t>()
         | Some msg1_static_dec => 
                guard eq(msg1_static_dec, dhpk_S_init) in 
                let H3 = crh(H2 ++ dhpk_S_init) in
                let C3 = hash<msg1_C3, msg1_C3_resp_corr[msg1_ephemeral];0>(C2, dh_combine(dhpk_S_init, get(S_resp))) in
                let k1 = hash<msg1_C3, msg1_C3_resp_corr[msg1_ephemeral];1>(C2, dh_combine(dhpk_S_init, get(S_resp))) in
                
                corr_case msg1_C3[;1] when (msg1_ephemeral == dhpk(get(E_init))) in
                case st_aead_dec(k1, msg1_timestamp, 0x, H3) {
                | None => None<ty:responder_msg1_val_t>()
                | Some msg1_timestamp_dec =>
                   let H4 = crh(H3 ++ msg1_timestamp_dec) in

                   let retval = responder_msg1_val(C3, H4, msg1_ephemeral, msg1_sender) in
                   Some(retval)
                }
     }
    

def generate_msg2 (msg1_val: responder_msg1_val_t, dhpk_S_init : dhpk(S_init)) @ Responder 
    : transp_keys_resp_t = 
     set_option ":rlimit" "2000000" in 
    let C3' = _responder_msg1_C3(msg1_val) in     
    let H4 = _responder_msg1_H4(msg1_val) in
    let ephemeral = _responder_msg1_ephemeral(msg1_val) in
    let msg2_receiver = _responder_msg1_sender(msg1_val) in
    assert (ephemeral == dhpk(get(E_init)) ==> C3' == get(msg1_C3[;0]));
    assert (ephemeral != dhpk(get(E_init)) ==> C3' == get(msg1_C3_resp_corr[ephemeral;0]));
    pcase (ephemeral == dhpk(get(E_init))) in 
    let C3 : if (ephemeral == dhpk(get(E_init))) then Name(msg1_C3[;0]) else Name(msg1_C3_resp_corr[ephemeral;0]) = C3' in
    let psk = 0x00000000 in // should be zeros(32)
    let C4 = hash<msg2_C4,msg2_C4_resp_corr[ephemeral]>(C3, dhpk(get(E_resp))) in
    let msg2_ephemeral = dhpk(get(E_resp)) in
    let H5 = crh(H4 ++ msg2_ephemeral) in
    let C5 = hash<msg2_C5, msg2_C5_resp_corr[ephemeral]>(C4, dh_combine(ephemeral, get(E_resp))) in
    let C6 = hash<msg2_C6, msg2_C6_resp_corr[ephemeral]>(C5, dh_combine(dhpk_S_init, get(E_resp))) in
    let C7 = hash<msg2_C7, msg2_C7_resp_corr[ephemeral];0>(C6, psk) in
    let tau = hash<msg2_C7, msg2_C7_resp_corr[ephemeral];1>(C6, psk) in
    let k0 = hash<msg2_C7, msg2_C7_resp_corr[ephemeral];2>(C6, psk) in
    let H6 : Data<adv> = crh(H5 ++ tau) in
    let emptystring : Data<adv> |0| = call get_empty_r() in
    let msg2_empty : Data<adv> |cipherlen(0)| = st_aead_enc<aead_counter_msg2_C7>(k0, emptystring, H6) in
    let H7 = crh(H6 ++ msg2_empty) in
    let msg2_sender : Data<adv> |4| = call get_sender_r() in
    let msg2_reserved : Data<adv> |3| = call get_padding_r() in
    let msg2_mac1_k = hash<msg2_mac1_key>(mac1(), dhpk_S_init) in
    // // TODO this needs to incorporate the tag byte
    let msg2_mac1 : Data<adv> | |maclen| | = mac(msg2_mac1_k,
        msg2_reserved ++ msg2_sender ++ msg2_receiver ++ msg2_ephemeral ++
        msg2_empty) in 
    let msg2_payload_value = msg2_payload(
        msg2_reserved, msg2_sender, msg2_receiver, msg2_ephemeral, msg2_empty, msg2_mac1
    ) in
    let msg2_output = msg2(msg2_payload_value) in
    let _ = output msg2_output in
    
    // Calculate transport keys
    let T_resp_recv = hash<transp_T, transp_T_resp_corr[ephemeral];0>(C7, 0x) in
    let T_resp_send = hash<transp_T, transp_T_resp_corr[ephemeral];1>(C7, 0x) in
    let retval = transp_keys(msg2_receiver, msg2_sender, ephemeral, msg2_ephemeral, T_resp_recv, T_resp_send) in
    retval 

def receive_msg2 (msg1_val: initiator_msg1_val, dhpk_S_resp : dhpk(S_resp)) @ Initiator 
    : Option (transp_keys_init_t) =
    set_option ":rlimit" "2000000" in 
    input inp in
    let msg2_reserved = _msg2_reserved(inp) in
    let msg2_sender = _msg2_sender(inp) in 
    let msg2_receiver = _msg2_receiver(inp) in
    let msg2_ephemeral = _msg2_ephemeral(inp) in
    let msg2_empty = _msg2_empty(inp) in
    let msg2_mac1 = _msg2_mac1(inp) in
    let C3 = _initiator_msg1_C3(msg1_val) in
    let H4 = _initiator_msg1_H4(msg1_val) in

    guard andb(eq(length(msg2_sender), 4), eq(length(msg2_receiver), 4)) in
    guard is_group_elem(msg2_ephemeral) in 

    let psk = 0x00000000 in // should be zeros(32)

    pcase (msg2_ephemeral == dhpk(get(E_resp))) in

    let C4 = hash<msg2_C4, msg2_C4_init_corr[msg2_ephemeral]>(C3, msg2_ephemeral) in
    let H5 = crh(H4 ++ msg2_ephemeral) in
    
    let C5 = hash<msg2_C5, msg2_C5_init_corr[msg2_ephemeral]>(C4, dh_combine(msg2_ephemeral, get(E_init))) in

    let C6 = hash<msg2_C6, msg2_C6_init_corr[msg2_ephemeral]>(C5, dh_combine(msg2_ephemeral, get(S_init))) in
    let C7 = hash<msg2_C7, msg2_C7_init_corr[msg2_ephemeral];0>(C6, psk) in
    let tau = hash<msg2_C7, msg2_C7_init_corr[msg2_ephemeral];1>(C6, psk) in
    let k0 = hash<msg2_C7, msg2_C7_init_corr[msg2_ephemeral];2>(C6, psk) in
    let H6 : Data<adv> = crh(H5 ++ tau) in
    let emptystring : Data<adv> |0| = call get_empty_i() in
    
    corr_case msg2_C7[;2] when (msg2_ephemeral == dhpk(get(E_resp))) in
    corr_case msg2_C7_init_corr[msg2_ephemeral;2] when (msg2_ephemeral != dhpk(get(E_resp))) in
    case st_aead_dec(k0, msg2_empty, 0x, H6) {
    | None => None<ty:transp_keys_init_t>()
    | Some msg2_empty_dec => 
        false_elim in 
        guard eq(msg2_empty_dec, emptystring) in 
        let H7 = crh(H6 ++ msg2_empty) in
        
        // Calculate transport keys
        let T_init_send = hash<transp_T, transp_T_init_corr[msg2_ephemeral];0>(C7, 0x) in
        let T_init_recv = hash<transp_T, transp_T_init_corr[msg2_ephemeral];1>(C7, 0x) in
        assert ((T_init_send == get(transp_T[;0])) \/ (T_init_send == get(transp_T_init_corr[msg2_ephemeral;0]) 
                                                       /\
                                                       [msg2_C7_init_corr[msg2_ephemeral;2]] <= adv));


        let retval = transp_keys(msg2_receiver, msg2_sender, dhpk(get(E_init)), msg2_ephemeral, T_init_send, T_init_recv) in
        Some(retval)
    }

def transp_send_init (transp_keys_val : transp_keys_init_t, plaintext : payload_i2r) @ Initiator 
    : Option(Unit) = 
    let eph_resp = _transp_keys_resp_ephemeral(transp_keys_val) in
    pcase (eph_resp == dhpk(get(E_resp))) in 
    let i2r : if eph_resp == dhpk(get(E_resp)) then Name(transp_T[;0]) 
                                               else Name(transp_T_init_corr[eph_resp;0]) 
        = _transp_keys_T_init_send(transp_keys_val) in       
    let transp_counter = get_counter N_init_send in
    assume(length(transp_counter) == 8); // TODO add |counter| length const

    let transp_receiver = _transp_keys_responder(transp_keys_val) in
    let transp_reserved = call get_padding_i() in
    guard eq(length(transp_receiver), 4) in 

    let transp_packet = st_aead_enc<N_init_send>(i2r, plaintext, 0x) in

    let transp_payload_value = transp_payload(transp_reserved, transp_receiver, transp_counter, transp_packet) in
    let transp_output = transp(transp_payload_value) in
    let _ = output transp_output in
    Some(())
    
predicate init_recv_secure(k) = 
    let eph_resp = _transp_keys_resp_ephemeral(k) in
    (_transp_keys_T_resp_send(k) == get(transp_T[;1])
     /\
     sec(transp_T[;1]))
    \/
    (_transp_keys_T_resp_send(k) == get(transp_T_init_corr[eph_resp;1])
     /\
     sec(transp_T_init_corr[eph_resp;1]))
    

def transp_recv_init (transp_keys_val : transp_keys_init_t, c : Data<adv>) @ Initiator :   
    Option(if init_recv_secure[transp_keys_val] then payload_r2i else Data<adv>)
    = 
    let from = _transp_receiver(c) in 
    guard eq(c, _transp_keys_responder(transp_keys_val)) in 
    let ctr = _transp_counter(c) in 
    let pkt = _transp_packet(c) in 
    let eph_resp = _transp_keys_resp_ephemeral(transp_keys_val) in
    pcase (eph_resp == dhpk(get(E_resp))) in 
    let r2i : if eph_resp == dhpk(get(E_resp)) then Name(transp_T[;1]) 
                                               else
                                                   Name(transp_T_init_corr[eph_resp;1]) 
        = _transp_keys_T_resp_send(transp_keys_val) in       
    corr_case transp_T[;1] when (eph_resp == dhpk(get(E_resp))) in
    corr_case transp_T_init_corr[eph_resp;1] when (eph_resp != dhpk(get(E_resp))) in
    st_aead_dec(r2i, pkt, 0x, ctr)
    




def transp_send_resp (transp_keys_val : transp_keys_resp_t, plaintext : Data<adv
/\ [channel_secret], |adv|>) @ Responder 
    : Option(Unit) = 
    let eph_init = _transp_keys_init_ephemeral(transp_keys_val) in
    pcase (eph_init == dhpk(get(E_init))) in 
    let r2i : if eph_init == dhpk(get(E_init)) then Name(transp_T[;1]) 
                                               else
                                                   Name(transp_T_resp_corr[eph_init;1]) 
        = _transp_keys_T_resp_send(transp_keys_val) in       
    let transp_counter = get_counter N_resp_send in
    assume(length(transp_counter) == 8); // TODO add |counter| length const

    let transp_receiver = _transp_keys_initiator(transp_keys_val) in
    let transp_reserved = call get_padding_r() in
    guard eq(length(transp_receiver), 4) in 

    let transp_packet = st_aead_enc<N_resp_send>(r2i, plaintext, 0x) in

    let transp_payload_value = transp_payload(transp_reserved, transp_receiver, transp_counter, transp_packet) in
    let transp_output = transp(transp_payload_value) in
    let _ = output transp_output in
    Some(())

predicate resp_recv_secure(k) = 
    let eph_init = _transp_keys_init_ephemeral(k) in
    (_transp_keys_T_init_send(k) == get(transp_T[;0])
     /\
     sec(transp_T[;0]))
    \/
    (_transp_keys_T_init_send(k) == get(transp_T_resp_corr[eph_init;0])
     /\
     sec(transp_T_resp_corr[eph_init;0]))
    

def transp_recv_resp (transp_keys_val : transp_keys_resp_t, c : Data<adv>) @ Responder :   
    Option(if resp_recv_secure[transp_keys_val] then payload_i2r else Data<adv>)
    = 
    let from = _transp_receiver(c) in 
    guard eq(c, _transp_keys_initiator(transp_keys_val)) in 
    let ctr = _transp_counter(c) in 
    let pkt = _transp_packet(c) in 
    let eph_init = _transp_keys_init_ephemeral(transp_keys_val) in
    pcase (eph_init == dhpk(get(E_init))) in 
    let i2r : if eph_init == dhpk(get(E_init)) then Name(transp_T[;0]) 
                                               else
                                                   Name(transp_T_resp_corr[eph_init;0]) 
        = _transp_keys_T_init_send(transp_keys_val) in       
    corr_case transp_T[;0] when (eph_init == dhpk(get(E_init))) in
    corr_case transp_T_resp_corr[eph_init;0] when (eph_init != dhpk(get(E_init))) in
    st_aead_dec(i2r, pkt, 0x, ctr)
