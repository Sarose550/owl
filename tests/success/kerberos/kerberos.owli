/*
 Owl implementations of the Kerberos protocol in both standard (all keys
 pre-shared) mode and PK_INIT mode, where initial set-up between the
 client and authentication server uses a public key infrastructure.

 Key hierarchy for STANDARD mode:

  kC    kT
   \    /
     AK    kS
      \    /
        SK

 Key hierarchy for PK_INIT mode:

            sigCA
             |
     pkeC   sigA
        \   /
  kT      K
    \    / 
      AK    kS
       \    /
         SK
 
  where:
  - kX   = pre-shared symmetric key
  - pkeX = secret key for PKE
  - sigX = signing key
  - XK   = symmetric key generated by X
 
  - C  = client
  - A  = authentication server
  - T  = ticket server
  - S  = service
  - CA = certificate authority
*/


// *********************************
// localities
// *********************************

locality ticketserver // TGS
locality service // S
locality client // C
locality authserver // KAS

name uname : nonce @ ticketserver, service, client, authserver
corr adv ==> [uname]

// *********************************
// keys for Kerberos stages 2 and 3
// *********************************

// SK = service key
name SK : enckey Data<adv> @ ticketserver

// messages to/from the ticket server
// encrypted using AK
enum AKEnum {
    | ClientRequest
    | TicketResponse Name(SK)
}

// AK = authserver key
name AK : enckey AKEnum @ authserver

// pre-shared symmetric keys
name kT : enckey Name(AK) @ authserver, ticketserver
name kS : enckey Name(SK) @ ticketserver, service

// *********************************
// message formats
// *********************************

struct authserver_msg {
    _authserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _authserver_msg_2 : Data<adv> |cipherlen(|enckey|)|
}

struct client_to_ticketserver_msg {
    _client_to_ticketserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _client_to_ticketserver_msg_2 : Data<adv> |cipherlen(|tag|)|
}

struct ticketserver_msg {
    _ticketserver_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _ticketserver_msg_2 : Data<adv> |cipherlen(plus(|tag|, |enckey|))|
}

struct client_to_service_msg {
    _client_to_service_msg_1 : Data<adv> |cipherlen(|enckey|)|,
    _client_to_service_msg_2 : Data<adv> |cipherlen(|nonce|)|
}

name K // : enckey Name(AK) @ authserver

def client_kerberos (ak: if sec(K) then Name(AK) else Data<adv>, tgt : Data<adv>
|cipherlen(|enckey|)|, username : Data<adv> ||nonce||) @ client 
    requires [AK] <= [K]
: Unit

